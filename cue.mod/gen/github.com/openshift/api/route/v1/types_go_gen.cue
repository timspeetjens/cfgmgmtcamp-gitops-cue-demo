// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/openshift/api/route/v1

package v1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	corev1 "k8s.io/api/core/v1"
)

// A route allows developers to expose services through an HTTP(S) aware load balancing and proxy
// layer via a public DNS entry. The route may further specify TLS options and a certificate, or
// specify a public CNAME that the router should also accept for HTTP and HTTPS traffic. An
// administrator typically configures their router to be visible outside the cluster firewall, and
// may also add additional security, caching, or traffic controls on the service content. Routers
// usually talk directly to the service endpoints.
//
// Once a route is created, the `host` field may not be changed. Generally, routers use the oldest
// route with a given host when resolving conflicts.
//
// Routers are subject to additional customization and may support additional controls via the
// annotations field.
//
// Because administrators may configure multiple routers, the route status field is used to
// return information to clients about the names and states of the route under each router.
// If a client chooses a duplicate name, for instance, the route status conditions are used
// to indicate the route cannot be chosen.
//
// To enable HTTP/2 ALPN on a route it requires a custom
// (non-wildcard) certificate. This prevents connection coalescing by
// clients, notably web browsers. We do not support HTTP/2 ALPN on
// routes that use the default certificate because of the risk of
// connection re-use/coalescing. Routes that do not have their own
// custom certificate will not be HTTP/2 ALPN-enabled on either the
// frontend or the backend.
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
// +openshift:compatibility-gen:level=1
#Route: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// spec is the desired state of the route
	spec: #RouteSpec @go(Spec) @protobuf(2,bytes,opt)

	// status is the current state of the route
	// +optional
	status?: #RouteStatus @go(Status) @protobuf(3,bytes,opt)
}

// RouteList is a collection of Routes.
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
// +openshift:compatibility-gen:level=1
#RouteList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// items is a list of routes
	items: [...#Route] @go(Items,[]Route) @protobuf(2,bytes,rep)
}

// RouteSpec describes the hostname or path the route exposes, any security information,
// and one to four backends (services) the route points to. Requests are distributed
// among the backends depending on the weights assigned to each backend. When using
// roundrobin scheduling the portion of requests that go to each backend is the backend
// weight divided by the sum of all of the backend weights. When the backend has more than
// one endpoint the requests that end up on the backend are roundrobin distributed among
// the endpoints. Weights are between 0 and 256 with default 100. Weight 0 causes no requests
// to the backend. If all weights are zero the route will be considered to have no backends
// and return a standard 503 response.
//
// The `tls` field is optional and allows specific certificates or behavior for the
// route. Routers typically configure a default certificate on a wildcard domain to
// terminate routes without explicit certificates, but custom hostnames usually must
// choose passthrough (send traffic directly to the backend via the TLS Server-Name-
// Indication field) or provide a certificate.
#RouteSpec: {
	// host is an alias/DNS that points to the service. Optional.
	// If not specified a route name will typically be automatically
	// chosen.
	// Must follow DNS952 subdomain conventions.
	// +optional
	host?: string @go(Host) @protobuf(1,bytes,opt)

	// subdomain is a DNS subdomain that is requested within the ingress controller's
	// domain (as a subdomain). If host is set this field is ignored. An ingress
	// controller may choose to ignore this suggested name, in which case the controller
	// will report the assigned name in the status.ingress array or refuse to admit the
	// route. If this value is set and the server does not support this field host will
	// be populated automatically. Otherwise host is left empty. The field may have
	// multiple parts separated by a dot, but not all ingress controllers may honor
	// the request. This field may not be changed after creation except by a user with
	// the update routes/custom-host permission.
	//
	// Example: subdomain `frontend` automatically receives the router subdomain
	// `apps.mycluster.com` to have a full hostname `frontend.apps.mycluster.com`.
	//
	// +optional
	subdomain?: string @go(Subdomain) @protobuf(8,bytes,opt)

	// path that the router watches for, to route traffic for to the service. Optional
	path?: string @go(Path) @protobuf(2,bytes,opt)

	// to is an object the route should use as the primary backend. Only the Service kind
	// is allowed, and it will be defaulted to Service. If the weight field (0-256 default 100)
	// is set to zero, no traffic will be sent to this backend.
	to: #RouteTargetReference @go(To) @protobuf(3,bytes,opt)

	// alternateBackends allows up to 3 additional backends to be assigned to the route.
	// Only the Service kind is allowed, and it will be defaulted to Service.
	// Use the weight field in RouteTargetReference object to specify relative preference.
	alternateBackends?: [...#RouteTargetReference] @go(AlternateBackends,[]RouteTargetReference) @protobuf(4,bytes,rep)

	// If specified, the port to be used by the router. Most routers will use all
	// endpoints exposed by the service by default - set this value to instruct routers
	// which port to use.
	port?: null | #RoutePort @go(Port,*RoutePort) @protobuf(5,bytes,opt)

	// The tls field provides the ability to configure certificates and termination for the route.
	tls?: null | #TLSConfig @go(TLS,*TLSConfig) @protobuf(6,bytes,opt)

	// Wildcard policy if any for the route.
	// Currently only 'Subdomain' or 'None' is allowed.
	wildcardPolicy?: #WildcardPolicyType @go(WildcardPolicy) @protobuf(7,bytes,opt)
}

// RouteTargetReference specifies the target that resolve into endpoints. Only the 'Service'
// kind is allowed. Use 'weight' field to emphasize one over others.
#RouteTargetReference: {
	// The kind of target that the route is referring to. Currently, only 'Service' is allowed
	kind: string @go(Kind) @protobuf(1,bytes,opt)

	// name of the service/target that is being referred to. e.g. name of the service
	name: string @go(Name) @protobuf(2,bytes,opt)

	// weight as an integer between 0 and 256, default 100, that specifies the target's relative weight
	// against other target reference objects. 0 suppresses requests to this backend.
	// +optional
	weight?: null | int32 @go(Weight,*int32) @protobuf(3,varint,opt)
}

// RoutePort defines a port mapping from a router to an endpoint in the service endpoints.
#RoutePort: {
	// The target port on pods selected by the service this route points to.
	// If this is a string, it will be looked up as a named port in the target
	// endpoints port list. Required
	targetPort: intstr.#IntOrString @go(TargetPort) @protobuf(1,bytes,opt)
}

// RouteStatus provides relevant info about the status of a route, including which routers
// acknowledge it.
#RouteStatus: {
	// ingress describes the places where the route may be exposed. The list of
	// ingress points may contain duplicate Host or RouterName values. Routes
	// are considered live once they are `Ready`
	ingress?: [...#RouteIngress] @go(Ingress,[]RouteIngress) @protobuf(1,bytes,rep)
}

// RouteIngress holds information about the places where a route is exposed.
#RouteIngress: {
	// Host is the host string under which the route is exposed; this value is required
	host?: string @go(Host) @protobuf(1,bytes,opt)

	// Name is a name chosen by the router to identify itself; this value is required
	routerName?: string @go(RouterName) @protobuf(2,bytes,opt)

	// Conditions is the state of the route, may be empty.
	conditions?: [...#RouteIngressCondition] @go(Conditions,[]RouteIngressCondition) @protobuf(3,bytes,rep)

	// Wildcard policy is the wildcard policy that was allowed where this route is exposed.
	wildcardPolicy?: #WildcardPolicyType @go(WildcardPolicy) @protobuf(4,bytes,opt)

	// CanonicalHostname is the external host name for the router that can be used as a CNAME
	// for the host requested for this route. This value is optional and may not be set in all cases.
	routerCanonicalHostname?: string @go(RouterCanonicalHostname) @protobuf(5,bytes,opt)
}

// RouteIngressConditionType is a valid value for RouteCondition
#RouteIngressConditionType: string // #enumRouteIngressConditionType

#enumRouteIngressConditionType:
	#RouteAdmitted

// RouteAdmitted means the route is able to service requests for the provided Host
#RouteAdmitted: #RouteIngressConditionType & "Admitted"

// RouteIngressCondition contains details for the current condition of this route on a particular
// router.
#RouteIngressCondition: {
	// Type is the type of the condition.
	// Currently only Ready.
	type: #RouteIngressConditionType @go(Type) @protobuf(1,bytes,opt,casttype=RouteIngressConditionType)

	// Status is the status of the condition.
	// Can be True, False, Unknown.
	status: corev1.#ConditionStatus @go(Status) @protobuf(2,bytes,opt,casttype=k8s.io/api/core/v1.ConditionStatus)

	// (brief) reason for the condition's last transition, and is usually a machine and human
	// readable constant
	reason?: string @go(Reason) @protobuf(3,bytes,opt)

	// Human readable message indicating details about last transition.
	message?: string @go(Message) @protobuf(4,bytes,opt)

	// RFC 3339 date and time when this condition last transitioned
	lastTransitionTime?: null | metav1.#Time @go(LastTransitionTime,*metav1.Time) @protobuf(5,bytes,opt)
}

// RouterShard has information of a routing shard and is used to
// generate host names and routing table entries when a routing shard is
// allocated for a specific route.
// Caveat: This is WIP and will likely undergo modifications when sharding
//         support is added.
#RouterShard: {
	// shardName uniquely identifies a router shard in the "set" of
	// routers used for routing traffic to the services.
	shardName: string @go(ShardName) @protobuf(1,bytes,opt)

	// dnsSuffix for the shard ala: shard-1.v3.openshift.com
	dnsSuffix: string @go(DNSSuffix) @protobuf(2,bytes,opt)
}

// TLSConfig defines config used to secure a route and provide termination
#TLSConfig: {
	// termination indicates termination type.
	//
	// * edge - TLS termination is done by the router and http is used to communicate with the backend (default)
	// * passthrough - Traffic is sent straight to the destination without the router providing TLS termination
	// * reencrypt - TLS termination is done by the router and https is used to communicate with the backend
	termination: #TLSTerminationType @go(Termination) @protobuf(1,bytes,opt,casttype=TLSTerminationType)

	// certificate provides certificate contents. This should be a single serving certificate, not a certificate
	// chain. Do not include a CA certificate.
	certificate?: string @go(Certificate) @protobuf(2,bytes,opt)

	// key provides key file contents
	key?: string @go(Key) @protobuf(3,bytes,opt)

	// caCertificate provides the cert authority certificate contents
	caCertificate?: string @go(CACertificate) @protobuf(4,bytes,opt)

	// destinationCACertificate provides the contents of the ca certificate of the final destination.  When using reencrypt
	// termination this file should be provided in order to have routers use it for health checks on the secure connection.
	// If this field is not specified, the router may provide its own destination CA and perform hostname validation using
	// the short service name (service.namespace.svc), which allows infrastructure generated certificates to automatically
	// verify.
	destinationCACertificate?: string @go(DestinationCACertificate) @protobuf(5,bytes,opt)

	// insecureEdgeTerminationPolicy indicates the desired behavior for insecure connections to a route. While
	// each router may make its own decisions on which ports to expose, this is normally port 80.
	//
	// * Allow - traffic is sent to the server on the insecure port (default)
	// * Disable - no traffic is allowed on the insecure port.
	// * Redirect - clients are redirected to the secure port.
	insecureEdgeTerminationPolicy?: #InsecureEdgeTerminationPolicyType @go(InsecureEdgeTerminationPolicy) @protobuf(6,bytes,opt,casttype=InsecureEdgeTerminationPolicyType)
}

// TLSTerminationType dictates where the secure communication will stop
// TODO: Reconsider this type in v2
#TLSTerminationType: string // #enumTLSTerminationType

#enumTLSTerminationType:
	#TLSTerminationEdge |
	#TLSTerminationPassthrough |
	#TLSTerminationReencrypt

// InsecureEdgeTerminationPolicyType dictates the behavior of insecure
// connections to an edge-terminated route.
#InsecureEdgeTerminationPolicyType: string // #enumInsecureEdgeTerminationPolicyType

#enumInsecureEdgeTerminationPolicyType:
	#InsecureEdgeTerminationPolicyNone |
	#InsecureEdgeTerminationPolicyAllow |
	#InsecureEdgeTerminationPolicyRedirect

// TLSTerminationEdge terminate encryption at the edge router.
#TLSTerminationEdge: #TLSTerminationType & "edge"

// TLSTerminationPassthrough terminate encryption at the destination, the destination is responsible for decrypting traffic
#TLSTerminationPassthrough: #TLSTerminationType & "passthrough"

// TLSTerminationReencrypt terminate encryption at the edge router and re-encrypt it with a new certificate supplied by the destination
#TLSTerminationReencrypt: #TLSTerminationType & "reencrypt"

// InsecureEdgeTerminationPolicyNone disables insecure connections for an edge-terminated route.
#InsecureEdgeTerminationPolicyNone: #InsecureEdgeTerminationPolicyType & "None"

// InsecureEdgeTerminationPolicyAllow allows insecure connections for an edge-terminated route.
#InsecureEdgeTerminationPolicyAllow: #InsecureEdgeTerminationPolicyType & "Allow"

// InsecureEdgeTerminationPolicyRedirect redirects insecure connections for an edge-terminated route.
// As an example, for routers that support HTTP and HTTPS, the
// insecure HTTP connections will be redirected to use HTTPS.
#InsecureEdgeTerminationPolicyRedirect: #InsecureEdgeTerminationPolicyType & "Redirect"

// WildcardPolicyType indicates the type of wildcard support needed by routes.
#WildcardPolicyType: string // #enumWildcardPolicyType

#enumWildcardPolicyType:
	#WildcardPolicyNone |
	#WildcardPolicySubdomain

// WildcardPolicyNone indicates no wildcard support is needed.
#WildcardPolicyNone: #WildcardPolicyType & "None"

// WildcardPolicySubdomain indicates the host needs wildcard support for the subdomain.
// Example: For host = "www.acme.test", indicates that the router
//          should support requests for *.acme.test
//          Note that this will not match acme.test only *.acme.test
#WildcardPolicySubdomain: #WildcardPolicyType & "Subdomain"

// AllowNonDNSCompliantHostAnnotation indicates that the host name in a route
// configuration is not required to follow strict DNS compliance.
// Unless the annotation is set to true, the route host name must have at least one label.
// Labels must have no more than 63 characters from the set of
// alphanumeric characters, '-' or '.', and must start and end with an alphanumeric
// character. A trailing dot is not allowed. The total host name length must be no more
// than 253 characters.
//
// When the annotation is set to true, the host name must pass a smaller set of
// requirements, i.e.: character set as described above, and total host name
// length must be no more than 253 characters.
//
// NOTE: use of this annotation may validate routes that cannot be admitted and will
// not function.  The annotation is provided to allow a custom scenario, e.g. a custom
// ingress controller that relies on the route API, but for some customized purpose
// needs to use routes with invalid hosts.
#AllowNonDNSCompliantHostAnnotation: "route.openshift.io/allow-non-dns-compliant-host"

// IngressToRouteIngressClassControllerName is the name of the
// controller that translates ingresses into routes.  This value is
// intended to be used for the spec.controller field of ingressclasses.
#IngressToRouteIngressClassControllerName: "openshift.io/ingress-to-route"
